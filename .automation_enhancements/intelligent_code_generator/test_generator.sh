#!/bin/bash

# Intelligent Test Generator
# Generates unit tests for functions and classes

generate_test_for_function() {
    local source_file="$1"
    local function_name="$2"
    local class_name="$3"
    
    local test_file="${source_file%.*}Tests.swift"
    local test_class_name="${class_name}Tests"
    
    echo "Generating test for $function_name in $class_name"
    
    # Generate test class if it doesn't exist
    if [ ! -f "$test_file" ]; then
        generate_test_class "$test_file" "$test_class_name" "$class_name"
    fi
    
    # Generate specific test function
    generate_test_function "$test_file" "$function_name" "$class_name"
}

generate_test_class() {
    local test_file="$1"
    local test_class_name="$2"
    local source_class_name="$3"
    
    cat > "$test_file" << SWIFT
import XCTest
@testable import CodingReviewer

final class $test_class_name: XCTestCase {
    
    var sut: $source_class_name!
    
    override func setUp() {
        super.setUp()
        sut = $source_class_name()
    }
    
    override func tearDown() {
        sut = nil
        super.tearDown()
    }
    
    // Generated by Intelligent Code Generator
    // Add test functions below
}
SWIFT
    
    echo "✅ Test class $test_class_name generated in $test_file"
}

generate_test_function() {
    local test_file="$1"
    local function_name="$2"
    local class_name="$3"
    
    local test_function_name="test${function_name^}"
    
    # Insert test function before the closing brace
    local test_function=$(cat << SWIFT

    func $test_function_name() throws {
        // Given
        // TODO: Set up test conditions for $function_name
        
        // When
        // TODO: Call sut.$function_name()
        
        // Then
        // TODO: Assert expected outcomes
        // XCTAssertEqual(result, expected)
        
        // Generated by Intelligent Code Generator
    }
SWIFT
)
    
    # Add the test function to the file (before the last closing brace)
    if grep -q "// Add test functions below" "$test_file"; then
        sed -i '' "/\/\/ Add test functions below/a\\
$test_function" "$test_file"
        echo "✅ Test function $test_function_name added to $test_file"
    fi
}

# Generate tests for all functions in a file
generate_tests_for_file() {
    local source_file="$1"
    
    echo "🔍 Analyzing $source_file for testable functions..."
    
    # Extract function names from the source file
    local functions=$(grep -n "func " "$source_file" | grep -v "private" | grep -v "fileprivate")
    
    if [ -n "$functions" ]; then
        echo "$functions" | while IFS= read -r line; do
            local func_name=$(echo "$line" | sed 's/.*func \([a-zA-Z0-9_]*\).*/\1/')
            if [ -n "$func_name" ] && [ "$func_name" != "func" ]; then
                echo "  • Found function: $func_name"
                # generate_test_for_function "$source_file" "$func_name" "YourClass"
            fi
        done
    else
        echo "  ⚠️ No testable functions found in $source_file"
    fi
}

# Generate performance test
generate_performance_test() {
    local function_name="$1"
    local test_file="$2"
    
    cat << SWIFT

    func testPerformance$function_name() throws {
        measure {
            // TODO: Call the function being performance tested
            // sut.$function_name()
        }
        // Generated by Intelligent Code Generator
    }
SWIFT
}

